Title: Собираем Serenity
Priority: 0
# Собираем Serenity

{{TOC}}

Serenity - ключевой компонент Stappler, работающий в качестве веб-сервера, API-сервера и адаптера к базе данных. Его сборка сложнее сборки других компонентов, поскольку требует установки базы данных PostgreSQL и веб-сервера Apache HTTPD.

## Устанавливаем PostgreSQL
Serenity может работать с PostgreSQL версии 9.6, однако для полкоценной работы функций полнотекстового поиска требуется версия PostgreSQL 11. Для удобства работы проще устанавливать сразу [последнюю версию](https://www.postgresql.org/download/).

Настраиваем пароль основному пользователю и создаём базу данных:
```
sudo -u postgres psql

# далее в интерфейсе psql

# Не забудьте указать свой пароль,
# и вообще не используйте стандартного пользователя в публичных проектах
ALTER ROLE postgres WITH PASSWORD 'secret123'; 

CREATE DATABASE stappler;
```

Убеждаемся, что установлены заголовочные файлы клиентской библиотеки
```
sudo apt install libpq-dev # или аналогичная команда для вашего пакетного менеджера
```

## Устанавливаем Apache HTTPD
Serenity использует модифицированную версию Apache HTTPD. Для удобства установки используем репозиторий https://github.com/SBKarr/apache-httpd-serenity

Изменения касаются в основном отладочного доступа к подсистеме памяти и интеграции допонительного менеджера памяти, оптимизирующего распределение для использования с контейнерами, схожыми со стандартной библиотекой С++.

```
git clone https://github.com/SBKarr/apache-httpd-serenity
cd apache-httpd-serenity
./build-deps-ubuntu.sh
# или устанавливаем зависимости - libpcre3-dev libssl-dev libexpat1-dev libidn11-dev
./configure-serenity.sh `pwd`/../apache
make
make install
```

## Разворачиваем проект
[Исходный код шаблона проекта]([%sources]/templates/serenity target=_blank)

Создаём структуру проекта
```sh
cd ..
mkdir MySerenityProject
cd MySerenityProject
touch Makefile
mkdir www
mkdir conf
touch conf/serenity-local.conf
mkdir src
touch src/main.cpp
```

Создаём файл конфигурации **conf/serenity-local.conf**
```
# Стандатные параметры конфигурации
ServerAdmin you@example.com
ServerName localhost
Listen 8080 # порд нашего приложения

# Параметры конфигурации БД
DBDriver pgsql
DBDPersist On
DBDParams "host=localhost dbname=stappler user=postgres password=secret123"

# Рабочий хост
<VirtualHost *:8080>
	DocumentRoot "www" # Рабочая директория хоста
	ServerName localhost # Имя хоста

	ErrorLog "logs/test-error_log" # Лог ошибок
	CustomLog "logs/test-access_log" common # Лог доступа

	# Название инициирующей библиотеки и функции
	SerenitySource "Lib.so:CreateHelloWorldComponent"

	# Ключ безопасности сервера, используется для генерации связки ключей
	# generated with `base64 < /dev/urandom | tr -d 'O0Il1+/' | head -c 44; printf '\n'`
	SerenityServerKey F29ZmQnfHDw9ZPmTFDRgaS7oULttrqr5ojB8WD692XPA
</VirtualHost>
```

Cоздаём **Makefile**:
```make
STAPPLER_ROOT ?= ../../..
LOCAL_ROOT = .

# директория сборки
LOCAL_OUTDIR := lib

# название собираемой библиотеки
LOCAL_LIBRARY := Lib

# используем набор инструментов serenity
LOCAL_TOOLKIT := serenity

# определяем путь для установки напрямую в директорию сборки
LOCAL_INSTALL_DIR := $(LOCAL_OUTDIR)

# Собираем директорию src
LOCAL_SRCS_DIRS :=  src
LOCAL_SRCS_OBJS :=

# Разрешаем включение файлов из src
LOCAL_INCLUDES_DIRS := src
LOCAL_INCLUDES_OBJS :=

# переопределяем стандартные опции оптимизации, чтобы включить названия функции
LOCAL_OPTIMIZATION := -g -O2

#вызов make all будет автоматически копировать собранный файл в директорию назначения
LOCAL_FORCE_INSTALL := 1

#задаём путь к файлам конфигурации
CONF_DIR:= $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

# инициируем сборку как локальную, поскольку serenity собирается
# только для теущей системы и недоступна для кросс-компиляции
include $(STAPPLER_ROOT)/make/local.mk

#экспортируем конфигурацию по умолчанию для скрипта сборки конфига
export SERENITY_DEFAULT_CONFIG

# команда для сборки файла конфигурации
# этот файл конфигурации используется только для отладки,
# для релиза нужен полноценно сконфигурированный сервер
$(LOCAL_OUTDIR)/httpd.conf: Makefile
	@mkdir -p $(LOCAL_OUTDIR)
	@mkdir -p $(CONF_DIR)logs
	@echo '# Autogenerated by makefile\n' > $@
	@echo "$$SERENITY_DEFAULT_CONFIG" >> $@
	@echo 'ServerRoot "$(CONF_DIR)"' >> $@
	@echo 'ErrorLog "$(CONF_DIR)logs/error_log"' >> $@
	@echo 'CustomLog "$(CONF_DIR)logs/access_log" common' >> $@
	@echo 'SerenitySourceRoot "$(CONF_DIR)lib"' >> $@
	@echo 'Include $(CONF_DIR)conf/serenity-local.conf' >> $@

all: $(LOCAL_OUTDIR)/httpd.conf
```
Создаём **src/main.cpp**:
```cpp
#include "ServerComponent.h"
#include "RequestHandler.h"

// Макрос для универсального определения неймспейса
// при использовании Serenity и Stellator в одном проекте
NS_SA_EXT_BEGIN(helloworld)

// Код возвращаемой страницы
static constexpr auto HELLO_WORLD_PAGE(
R"HelpString(<!DOCTYPE html>
<html>
<head><title>Hello world</title></head>
<body><h1>Hello world</h1></body>
</html>)HelpString");

// Хэндлер запроса, возвращающий страницу
class HelloWorldHandler : public RequestHandler {
public:
	virtual ~HelloWorldHandler() { }
	
	// Функция определяет доступность адреса, при неудаче возвращает 403
	virtual bool isRequestPermitted(Request &req) override;
	
	// Функция ранней обработки запроса (на стадии трансляции имени в файл)
	virtual int onTranslateName(Request &req) override;
};


// Компонент сервера, отвечающий за назначение хэндлеров
class HelloWorldComponent : public ServerComponent {
public:
	HelloWorldComponent(Server &serv, const String &name, const data::Value &dict);
	virtual ~HelloWorldComponent() { }

	// Функция инициализации сервера после выполнения всех шагов конфигурации
	virtual void onChildInit(Server &) override;
};


bool HelloWorldHandler::isRequestPermitted(Request &req) {
	return true; // разрешаем для всех
}

int HelloWorldHandler::onTranslateName(Request &req) {
	// выводим код страницы
	req << HELLO_WORLD_PAGE << "\n";
	return DONE;
}

HelloWorldComponent::HelloWorldComponent(Server &serv, const String &name, const data::Value &dict)
: ServerComponent(serv, name.empty()?"HelloWorld":name, dict) {
	
}

void HelloWorldComponent::onChildInit(Server &serv) {
	// привязываем хэндлер на все доступные адреса
	serv.addHandler("/", SA_HANDLER(HelloWorldHandler));
}

// Экспортируемая функция, которая будет нашей точкой входа в модуль
extern "C" ServerComponent * CreateHelloWorldComponent(Server &serv, const String &name, const data::Value &dict) {
	// возвращаем новый компонент
	return new HelloWorldComponent(serv, name, dict);
}

NS_SA_EXT_END(test)
```
Собираем с помощью
```
make
```
Для запуска используем команду
```
# абсолютный путь можно заменить `pwd`
<path-to-apache>/bin/httpd -f <absolute-path-to-proj>/lib/httpd.conf -X
```

Сервер должен корректно вернуть ответ по адресу `http://localhost:8080`
